import { tool } from "@langchain/core/tools";
import { z } from "zod";
import { ChatOpenAI } from "@langchain/openai";
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { HumanMessage } from "@langchain/core/messages";
import { SubAgentConfig } from "../types";
import { basicTools } from "./basic-tools";

// SubAgent é…ç½®å®šä¹‰
export const subAgentConfigs: SubAgentConfig[] = [
  {
    type: "general-purpose",
    systemPrompt: `ä½ æ˜¯ä¸€ä¸ªé€šç”¨çš„AIåŠ©æ‰‹ï¼Œä¸“é—¨å¤„ç†å¤æ‚çš„å¤šæ­¥éª¤ä»»åŠ¡ã€‚
- æ“…é•¿æ–‡ä»¶æœç´¢ã€å†…å®¹åˆ†æå’Œä»£ç ç†è§£
- ç³»ç»Ÿæ€§åœ°å¤„ç†å¤æ‚é—®é¢˜å¹¶å°†å…¶åˆ†è§£
- å§‹ç»ˆæä¾›è¯¦ç»†è€Œå‡†ç¡®çš„åˆ†æç»“æœ`,
    allowedTools: null // å…è®¸æ‰€æœ‰å·¥å…·
  },
  {
    type: "code-analyzer", 
    systemPrompt: `ä½ æ˜¯ä»£ç åˆ†æä¸“å®¶ï¼Œä¸“æ³¨äºï¼š
- ä»£ç è´¨é‡è¯„ä¼°å’Œæ”¹è¿›å»ºè®®
- æ¶æ„è®¾è®¡åˆ†æå’Œä¼˜åŒ–
- æ€§èƒ½ç“¶é¢ˆè¯†åˆ«å’Œè§£å†³æ–¹æ¡ˆ
- å®‰å…¨æ¼æ´æ£€æµ‹å’Œä¿®å¤å»ºè®®
è¯·æä¾›å…·ä½“çš„ã€å¯æ“ä½œçš„æŠ€æœ¯å»ºè®®`,
    allowedTools: ["ReadFile", "EditFile", "Grep", "ListDir"]
  },
  {
    type: "document-writer",
    systemPrompt: `ä½ æ˜¯æŠ€æœ¯å†™ä½œä¸“å®¶ï¼Œä¸“æ³¨äºï¼š
- æ¸…æ™°å‡†ç¡®çš„æŠ€æœ¯æ–‡æ¡£
- ç”¨æˆ·å‹å¥½çš„æ“ä½œæŒ‡å—  
- å®Œæ•´çš„APIæ–‡æ¡£å’Œç¤ºä¾‹
- ç»“æ„åŒ–çš„é¡¹ç›®æ–‡æ¡£
ç¡®ä¿æ–‡æ¡£çš„å¯è¯»æ€§å’Œå®ç”¨æ€§`,
    allowedTools: ["ReadFile", "WriteFile", "EditFile"]
  }
];

// TaskTool å®ç°
export function createTaskTool(baseTools: any[], model: ChatOpenAI) {
  // ä¸ºæ¯ç§ç±»å‹åˆ›å»ºä¸“é—¨çš„ ReActAgent å®ä¾‹
  const agentInstances = new Map<string, any>();
  
  // åˆå§‹åŒ–é¢„å®šä¹‰çš„ SubAgent ç±»å‹
  subAgentConfigs.forEach(config => {
    const filteredTools = config.allowedTools 
      ? baseTools.filter(tool => config.allowedTools!.includes(tool.name))
      : baseTools.filter(tool => tool.name !== "TaskTool"); // é˜²æ­¢é€’å½’
      
    agentInstances.set(config.type, createReactAgent({
      llm: model,
      tools: filteredTools,
      messageModifier: config.systemPrompt
    }));
  });
  
  return tool(
    async (args: { description: string; subagent_type: string }) => {
      const { description, subagent_type } = args;
      
      // è·å–æŒ‡å®šç±»å‹çš„ Agent
      const agent = agentInstances.get(subagent_type);
      if (!agent) {
        throw new Error(`Unknown SubAgent type: ${subagent_type}`);
      }
      
      // æ‰§è¡Œ SubAgent
      try {
        console.log(`ğŸ¤– Launching SubAgent [${subagent_type}]: ${description}`);
        
        // åˆ›å»ºéš”ç¦»çš„æ‰§è¡Œä¸Šä¸‹æ–‡
        const subAgentState = {
          messages: [new HumanMessage(description)]
        };
        
        // æ‰§è¡Œ Agent å¹¶è·å–ç»“æœ
        const result = await agent.invoke(subAgentState);
        
        // æå–æœ€ç»ˆå“åº”
        const finalMessage = result.messages[result.messages.length - 1];
        const responseContent = finalMessage.content;
        
        console.log(`âœ… SubAgent [${subagent_type}] completed`);
        
        // è¿”å›æ ¼å¼åŒ–ç»“æœ - æ¨¡æ‹Ÿ claude-code çš„ç»“æœæ ¼å¼
        return `SubAgent [${subagent_type}] execution completed:

Task: ${description}

Result:
${responseContent}

Note: This result was generated by a specialized SubAgent. Please summarize key information for the user as needed.`;
        
      } catch (error: any) {
        console.error(`âŒ SubAgent [${subagent_type}] failed:`, error);
        return `SubAgent [${subagent_type}] execution failed: ${error.message}`;
      }
    },
    {
      name: "TaskTool",
      description: `Launch specialized SubAgents to autonomously handle complex multi-step tasks.

Available Agent types:
- general-purpose: General agent suitable for complex queries, file searches, and multi-step task execution (Tools: *)
- code-analyzer: Code analysis expert for code review, architecture analysis, performance optimization
- document-writer: Documentation expert for technical docs, user manuals, API documentation

Usage rules:
1. Use this tool when tasks are complex and require specialized handling
2. Each SubAgent invocation is independent and stateless  
3. Provide detailed task descriptions; SubAgents will complete autonomously
4. After SubAgent completion, summarize key information for the user

When to use SubAgents:
- Complex multi-step analysis tasks
- Tasks requiring specialized skills (code analysis, documentation)
- Large-scale file search and processing
- Independent tasks that can be processed in parallel`,
      schema: z.object({
        description: z.string().describe("Detailed task description for the SubAgent"),
        subagent_type: z.enum(["general-purpose", "code-analyzer", "document-writer"]).describe("SubAgent type to use")
      })
    }
  );
}

// å¹¶å‘å·¥å…·åˆ†ç±»
export function categorizeToolsByConcurrency(tools: any[]) {
  // å¹¶å‘å®‰å…¨çš„å·¥å…·ï¼ˆåªè¯»æ“ä½œï¼‰
  const safeConcurrencyTools = tools.filter(tool => 
    ['ReadFile', 'Grep', 'ListDir', 'TaskTool', 'TodoRead'].includes(tool.name)
  );
  
  // å¹¶å‘ä¸å®‰å…¨çš„å·¥å…·ï¼ˆå†™æ“ä½œã€ç³»ç»Ÿå‘½ä»¤ç­‰ï¼‰
  const unsafeConcurrencyTools = tools.filter(tool => 
    ['WriteFile', 'EditFile', 'Bash', 'TodoWrite'].includes(tool.name)
  );
  
  return {
    safeConcurrencyTools,
    unsafeConcurrencyTools
  };
}

// æ£€æŸ¥å·¥å…·æ˜¯å¦ä¸ºå¹¶å‘å®‰å…¨çš„
export function isSafeConcurrencyTool(toolName: string): boolean {
  const safeTools = ['ReadFile', 'Grep', 'ListDir', 'TaskTool', 'TodoRead'];
  return safeTools.includes(toolName);
}
